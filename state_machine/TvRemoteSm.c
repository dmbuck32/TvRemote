// Autogenerated with StateSmith 0.9.10-alpha+1f83cb59adcabe0a5a4c8d3e0421027761c28974.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// TV Remote project for F&P Healthcare.

// Constants used by the code.
const unsigned short MAX_BRIGHTNESS = 100;
const unsigned short MIN_BRIGHTNESS = 0;
const unsigned short MAX_VOLUME = 100;
const unsigned short MIN_VOLUME = 0;
const unsigned short MAX_CHANNEL = 256;
const unsigned short MIN_CHANNEL = 1;

#include "TvRemoteSm.h"
#include <stdio.h> // For fprint.
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(TvRemoteSm* sm, TvRemoteSm_Func desired_state_exit_handler);

static void ROOT_enter(TvRemoteSm* sm);

static void ROOT_exit(TvRemoteSm* sm);

static void TV_OFF_enter(TvRemoteSm* sm);

static void TV_OFF_exit(TvRemoteSm* sm);

static void TV_OFF_b1_long_press(TvRemoteSm* sm);

static void TV_ON_enter(TvRemoteSm* sm);

static void TV_ON_exit(TvRemoteSm* sm);

static void TV_ON_b1_long_press(TvRemoteSm* sm);

static void BRIGHTNESS_CHANGE_enter(TvRemoteSm* sm);

static void BRIGHTNESS_CHANGE_exit(TvRemoteSm* sm);

static void BRIGHTNESS_CHANGE_b2_long_press(TvRemoteSm* sm);

static void BRIGHTNESS_CHANGE__INITIAL_enter(TvRemoteSm* sm);

static void BRIGHTNESS_CHANGE__INITIAL_exit(TvRemoteSm* sm);

static void BRIGHTNESS_CHANGE__INITIAL_b1_press(TvRemoteSm* sm);

static void BRIGHTNESS_CHANGE__INITIAL_b2_press(TvRemoteSm* sm);

static void BRIGHTNESS_DOWN_enter(TvRemoteSm* sm);

static void BRIGHTNESS_DOWN_exit(TvRemoteSm* sm);

static void BRIGHTNESS_DOWN_b1_press(TvRemoteSm* sm);

static void BRIGHTNESS_DOWN_b2_press(TvRemoteSm* sm);

static void BRIGHTNESS_UP_enter(TvRemoteSm* sm);

static void BRIGHTNESS_UP_exit(TvRemoteSm* sm);

static void BRIGHTNESS_UP_b1_press(TvRemoteSm* sm);

static void BRIGHTNESS_UP_b2_press(TvRemoteSm* sm);

static void CHANNEL_SELECT_enter(TvRemoteSm* sm);

static void CHANNEL_SELECT_exit(TvRemoteSm* sm);

static void CHANNEL_SELECT_b2_long_press(TvRemoteSm* sm);

static void CHANNEL_DOWN_enter(TvRemoteSm* sm);

static void CHANNEL_DOWN_exit(TvRemoteSm* sm);

static void CHANNEL_DOWN_b1_press(TvRemoteSm* sm);

static void CHANNEL_DOWN_b2_press(TvRemoteSm* sm);

static void CHANNEL_SELECT__INITIAL_enter(TvRemoteSm* sm);

static void CHANNEL_SELECT__INITIAL_exit(TvRemoteSm* sm);

static void CHANNEL_SELECT__INITIAL_b1_press(TvRemoteSm* sm);

static void CHANNEL_SELECT__INITIAL_b2_press(TvRemoteSm* sm);

static void CHANNEL_UP_enter(TvRemoteSm* sm);

static void CHANNEL_UP_exit(TvRemoteSm* sm);

static void CHANNEL_UP_b1_press(TvRemoteSm* sm);

static void CHANNEL_UP_b2_press(TvRemoteSm* sm);

static void VOLUME_CHANGE_enter(TvRemoteSm* sm);

static void VOLUME_CHANGE_exit(TvRemoteSm* sm);

static void VOLUME_CHANGE_b2_long_press(TvRemoteSm* sm);

static void VOLUME_CHANGE_InitialState_transition(TvRemoteSm* sm);

static void VOLUME_CHANGE__INITIAL_enter(TvRemoteSm* sm);

static void VOLUME_CHANGE__INITIAL_exit(TvRemoteSm* sm);

static void VOLUME_CHANGE__INITIAL_b1_press(TvRemoteSm* sm);

static void VOLUME_CHANGE__INITIAL_b2_press(TvRemoteSm* sm);

static void VOLUME_DOWN_enter(TvRemoteSm* sm);

static void VOLUME_DOWN_exit(TvRemoteSm* sm);

static void VOLUME_DOWN_b1_press(TvRemoteSm* sm);

static void VOLUME_DOWN_b2_press(TvRemoteSm* sm);

static void VOLUME_UP_enter(TvRemoteSm* sm);

static void VOLUME_UP_exit(TvRemoteSm* sm);

static void VOLUME_UP_b1_press(TvRemoteSm* sm);

static void VOLUME_UP_b2_press(TvRemoteSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void TvRemoteSm_ctor(TvRemoteSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void TvRemoteSm_start(TvRemoteSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(TV_OFF)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `TV_OFF`.
            TV_OFF_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = TvRemoteSm_StateId_TV_OFF;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void TvRemoteSm_dispatch_event(TvRemoteSm* sm, TvRemoteSm_EventId event_id)
{
    TvRemoteSm_Func behavior_func = sm->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        sm->ancestor_event_handler = NULL;
        behavior_func(sm);
        behavior_func = sm->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(TvRemoteSm* sm, TvRemoteSm_Func desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(TvRemoteSm* sm)
{
    // State machine root is a special case. It cannot be exited. Mark as unused.
    (void)sm;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TV_OFF
////////////////////////////////////////////////////////////////////////////////

static void TV_OFF_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = TV_OFF_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_LONG_PRESS] = TV_OFF_b1_long_press;
    
    // TV_OFF behavior
    // uml: enter / { show("TV OFF"); }
    {
        // Step 1: execute action `show("TV OFF");`
        printf("TV OFF");
    } // end of behavior for TV_OFF
}

static void TV_OFF_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_LONG_PRESS] = NULL;  // no ancestor listens to this event
}

static void TV_OFF_b1_long_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_long_press` event.
    
    // TV_OFF behavior
    // uml: B1_LONG_PRESS TransitionTo(TV_ON)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        TV_OFF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `TV_ON`.
        TV_ON_enter(sm);
        
        // TV_ON.<InitialState> behavior
        // uml: TransitionTo(VOLUME_CHANGE)
        {
            // Step 1: Exit states until we reach `TV_ON` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `VOLUME_CHANGE`.
            VOLUME_CHANGE_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            VOLUME_CHANGE_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TV_ON.<InitialState>
    } // end of behavior for TV_OFF
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TV_ON
////////////////////////////////////////////////////////////////////////////////

static void TV_ON_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = TV_ON_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_LONG_PRESS] = TV_ON_b1_long_press;
    
    // TV_ON behavior
    // uml: enter / { show("TV ON"); }
    {
        // Step 1: execute action `show("TV ON");`
        printf("TV ON");
    } // end of behavior for TV_ON
}

static void TV_ON_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_LONG_PRESS] = NULL;  // no ancestor listens to this event
}

static void TV_ON_b1_long_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_long_press` event.
    
    // TV_ON behavior
    // uml: B1_LONG_PRESS TransitionTo(TV_OFF)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `TV_OFF`.
        TV_OFF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_TV_OFF;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for TV_ON
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BRIGHTNESS_CHANGE
////////////////////////////////////////////////////////////////////////////////

static void BRIGHTNESS_CHANGE_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BRIGHTNESS_CHANGE_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_LONG_PRESS] = BRIGHTNESS_CHANGE_b2_long_press;
    
    // BRIGHTNESS_CHANGE behavior
    // uml: enter / { show("Brightness Change"); }
    {
        // Step 1: execute action `show("Brightness Change");`
        printf("Brightness Change");
    } // end of behavior for BRIGHTNESS_CHANGE
}

static void BRIGHTNESS_CHANGE_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = TV_ON_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_LONG_PRESS] = NULL;  // no ancestor listens to this event
}

static void BRIGHTNESS_CHANGE_b2_long_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_long_press` event.
    
    // BRIGHTNESS_CHANGE behavior
    // uml: B2_LONG_PRESS TransitionTo(VOLUME_CHANGE)
    {
        // Step 1: Exit states until we reach `TV_ON` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, TV_ON_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `VOLUME_CHANGE`.
        VOLUME_CHANGE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        VOLUME_CHANGE_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for BRIGHTNESS_CHANGE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BRIGHTNESS_CHANGE__INITIAL
////////////////////////////////////////////////////////////////////////////////

static void BRIGHTNESS_CHANGE__INITIAL_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BRIGHTNESS_CHANGE__INITIAL_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = BRIGHTNESS_CHANGE__INITIAL_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = BRIGHTNESS_CHANGE__INITIAL_b2_press;
}

static void BRIGHTNESS_CHANGE__INITIAL_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BRIGHTNESS_CHANGE_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void BRIGHTNESS_CHANGE__INITIAL_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // BRIGHTNESS_CHANGE__INITIAL behavior
    // uml: B1_PRESS TransitionTo(BRIGHTNESS_UP)
    {
        // Step 1: Exit states until we reach `BRIGHTNESS_CHANGE` state (Least Common Ancestor for transition).
        BRIGHTNESS_CHANGE__INITIAL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BRIGHTNESS_UP`.
        BRIGHTNESS_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_BRIGHTNESS_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BRIGHTNESS_CHANGE__INITIAL
}

static void BRIGHTNESS_CHANGE__INITIAL_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // BRIGHTNESS_CHANGE__INITIAL behavior
    // uml: B2_PRESS TransitionTo(BRIGHTNESS_DOWN)
    {
        // Step 1: Exit states until we reach `BRIGHTNESS_CHANGE` state (Least Common Ancestor for transition).
        BRIGHTNESS_CHANGE__INITIAL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BRIGHTNESS_DOWN`.
        BRIGHTNESS_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_BRIGHTNESS_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BRIGHTNESS_CHANGE__INITIAL
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BRIGHTNESS_DOWN
////////////////////////////////////////////////////////////////////////////////

static void BRIGHTNESS_DOWN_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BRIGHTNESS_DOWN_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = BRIGHTNESS_DOWN_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = BRIGHTNESS_DOWN_b2_press;
    
    // BRIGHTNESS_DOWN behavior
    // uml: enter / { show("Brightness Down");\nbrightness_decrement();\nprint_brightness(); }
    {
        // Step 1: execute action `show("Brightness Down");\nbrightness_decrement();\nprint_brightness();`
        printf("Brightness Down");
        if (sm->vars.brightness > MIN_BRIGHTNESS) { sm->vars.brightness--; };
        printf("%d", sm->vars.brightness);
    } // end of behavior for BRIGHTNESS_DOWN
}

static void BRIGHTNESS_DOWN_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BRIGHTNESS_CHANGE_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void BRIGHTNESS_DOWN_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // BRIGHTNESS_DOWN behavior
    // uml: B1_PRESS TransitionTo(BRIGHTNESS_UP)
    {
        // Step 1: Exit states until we reach `BRIGHTNESS_CHANGE` state (Least Common Ancestor for transition).
        BRIGHTNESS_DOWN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BRIGHTNESS_UP`.
        BRIGHTNESS_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_BRIGHTNESS_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BRIGHTNESS_DOWN
}

static void BRIGHTNESS_DOWN_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // BRIGHTNESS_DOWN behavior
    // uml: B2_PRESS TransitionTo(BRIGHTNESS_DOWN)
    {
        // Step 1: Exit states until we reach `BRIGHTNESS_CHANGE` state (Least Common Ancestor for transition).
        BRIGHTNESS_DOWN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BRIGHTNESS_DOWN`.
        BRIGHTNESS_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_BRIGHTNESS_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BRIGHTNESS_DOWN
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BRIGHTNESS_UP
////////////////////////////////////////////////////////////////////////////////

static void BRIGHTNESS_UP_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BRIGHTNESS_UP_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = BRIGHTNESS_UP_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = BRIGHTNESS_UP_b2_press;
    
    // BRIGHTNESS_UP behavior
    // uml: enter / { show("Brightness Up");\nbrightness_increment();\nprint_brightness(); }
    {
        // Step 1: execute action `show("Brightness Up");\nbrightness_increment();\nprint_brightness();`
        printf("Brightness Up");
        if (sm->vars.brightness < MAX_BRIGHTNESS) { sm->vars.brightness++; };
        printf("%d", sm->vars.brightness);
    } // end of behavior for BRIGHTNESS_UP
}

static void BRIGHTNESS_UP_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BRIGHTNESS_CHANGE_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void BRIGHTNESS_UP_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // BRIGHTNESS_UP behavior
    // uml: B1_PRESS TransitionTo(BRIGHTNESS_UP)
    {
        // Step 1: Exit states until we reach `BRIGHTNESS_CHANGE` state (Least Common Ancestor for transition).
        BRIGHTNESS_UP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BRIGHTNESS_UP`.
        BRIGHTNESS_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_BRIGHTNESS_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BRIGHTNESS_UP
}

static void BRIGHTNESS_UP_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // BRIGHTNESS_UP behavior
    // uml: B2_PRESS TransitionTo(BRIGHTNESS_DOWN)
    {
        // Step 1: Exit states until we reach `BRIGHTNESS_CHANGE` state (Least Common Ancestor for transition).
        BRIGHTNESS_UP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BRIGHTNESS_DOWN`.
        BRIGHTNESS_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_BRIGHTNESS_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BRIGHTNESS_UP
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CHANNEL_SELECT
////////////////////////////////////////////////////////////////////////////////

static void CHANNEL_SELECT_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CHANNEL_SELECT_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_LONG_PRESS] = CHANNEL_SELECT_b2_long_press;
    
    // CHANNEL_SELECT behavior
    // uml: enter / { show("Channel Select"); }
    {
        // Step 1: execute action `show("Channel Select");`
        printf("Channel Select");
    } // end of behavior for CHANNEL_SELECT
}

static void CHANNEL_SELECT_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = TV_ON_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_LONG_PRESS] = NULL;  // no ancestor listens to this event
}

static void CHANNEL_SELECT_b2_long_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_long_press` event.
    
    // CHANNEL_SELECT behavior
    // uml: B2_LONG_PRESS TransitionTo(BRIGHTNESS_CHANGE)
    {
        // Step 1: Exit states until we reach `TV_ON` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, TV_ON_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BRIGHTNESS_CHANGE`.
        BRIGHTNESS_CHANGE_enter(sm);
        
        // BRIGHTNESS_CHANGE.<InitialState> behavior
        // uml: TransitionTo(BRIGHTNESS_CHANGE__INITIAL)
        {
            // Step 1: Exit states until we reach `BRIGHTNESS_CHANGE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `BRIGHTNESS_CHANGE__INITIAL`.
            BRIGHTNESS_CHANGE__INITIAL_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = TvRemoteSm_StateId_BRIGHTNESS_CHANGE__INITIAL;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for BRIGHTNESS_CHANGE.<InitialState>
    } // end of behavior for CHANNEL_SELECT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CHANNEL_DOWN
////////////////////////////////////////////////////////////////////////////////

static void CHANNEL_DOWN_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CHANNEL_DOWN_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = CHANNEL_DOWN_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = CHANNEL_DOWN_b2_press;
    
    // CHANNEL_DOWN behavior
    // uml: enter / { show("Channel Down");\nchannel_decrement();\nprint_channel(); }
    {
        // Step 1: execute action `show("Channel Down");\nchannel_decrement();\nprint_channel();`
        printf("Channel Down");
        sm->vars.channel--; if (sm->vars.channel < MIN_CHANNEL) { sm->vars.channel = MAX_CHANNEL; };
        printf("%d", sm->vars.channel);
    } // end of behavior for CHANNEL_DOWN
}

static void CHANNEL_DOWN_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CHANNEL_SELECT_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void CHANNEL_DOWN_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // CHANNEL_DOWN behavior
    // uml: B1_PRESS TransitionTo(CHANNEL_UP)
    {
        // Step 1: Exit states until we reach `CHANNEL_SELECT` state (Least Common Ancestor for transition).
        CHANNEL_DOWN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHANNEL_UP`.
        CHANNEL_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_CHANNEL_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CHANNEL_DOWN
}

static void CHANNEL_DOWN_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // CHANNEL_DOWN behavior
    // uml: B2_PRESS TransitionTo(CHANNEL_DOWN)
    {
        // Step 1: Exit states until we reach `CHANNEL_SELECT` state (Least Common Ancestor for transition).
        CHANNEL_DOWN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHANNEL_DOWN`.
        CHANNEL_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_CHANNEL_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CHANNEL_DOWN
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CHANNEL_SELECT__INITIAL
////////////////////////////////////////////////////////////////////////////////

static void CHANNEL_SELECT__INITIAL_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CHANNEL_SELECT__INITIAL_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = CHANNEL_SELECT__INITIAL_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = CHANNEL_SELECT__INITIAL_b2_press;
}

static void CHANNEL_SELECT__INITIAL_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CHANNEL_SELECT_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void CHANNEL_SELECT__INITIAL_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // CHANNEL_SELECT__INITIAL behavior
    // uml: B1_PRESS TransitionTo(CHANNEL_UP)
    {
        // Step 1: Exit states until we reach `CHANNEL_SELECT` state (Least Common Ancestor for transition).
        CHANNEL_SELECT__INITIAL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHANNEL_UP`.
        CHANNEL_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_CHANNEL_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CHANNEL_SELECT__INITIAL
}

static void CHANNEL_SELECT__INITIAL_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // CHANNEL_SELECT__INITIAL behavior
    // uml: B2_PRESS TransitionTo(CHANNEL_DOWN)
    {
        // Step 1: Exit states until we reach `CHANNEL_SELECT` state (Least Common Ancestor for transition).
        CHANNEL_SELECT__INITIAL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHANNEL_DOWN`.
        CHANNEL_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_CHANNEL_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CHANNEL_SELECT__INITIAL
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CHANNEL_UP
////////////////////////////////////////////////////////////////////////////////

static void CHANNEL_UP_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CHANNEL_UP_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = CHANNEL_UP_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = CHANNEL_UP_b2_press;
    
    // CHANNEL_UP behavior
    // uml: enter / { show("Channel Up");\nchannel_increment();\nprint_channel(); }
    {
        // Step 1: execute action `show("Channel Up");\nchannel_increment();\nprint_channel();`
        printf("Channel Up");
        sm->vars.channel++; if (sm->vars.channel > MAX_CHANNEL) { sm->vars.channel = MIN_CHANNEL; };
        printf("%d", sm->vars.channel);
    } // end of behavior for CHANNEL_UP
}

static void CHANNEL_UP_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CHANNEL_SELECT_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void CHANNEL_UP_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // CHANNEL_UP behavior
    // uml: B1_PRESS TransitionTo(CHANNEL_UP)
    {
        // Step 1: Exit states until we reach `CHANNEL_SELECT` state (Least Common Ancestor for transition).
        CHANNEL_UP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHANNEL_UP`.
        CHANNEL_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_CHANNEL_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CHANNEL_UP
}

static void CHANNEL_UP_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // CHANNEL_UP behavior
    // uml: B2_PRESS TransitionTo(CHANNEL_DOWN)
    {
        // Step 1: Exit states until we reach `CHANNEL_SELECT` state (Least Common Ancestor for transition).
        CHANNEL_UP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHANNEL_DOWN`.
        CHANNEL_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_CHANNEL_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CHANNEL_UP
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state VOLUME_CHANGE
////////////////////////////////////////////////////////////////////////////////

static void VOLUME_CHANGE_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = VOLUME_CHANGE_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_LONG_PRESS] = VOLUME_CHANGE_b2_long_press;
    
    // VOLUME_CHANGE behavior
    // uml: enter / { show("Volume Change"); }
    {
        // Step 1: execute action `show("Volume Change");`
        printf("Volume Change");
    } // end of behavior for VOLUME_CHANGE
}

static void VOLUME_CHANGE_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = TV_ON_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_LONG_PRESS] = NULL;  // no ancestor listens to this event
}

static void VOLUME_CHANGE_b2_long_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_long_press` event.
    
    // VOLUME_CHANGE behavior
    // uml: B2_LONG_PRESS TransitionTo(CHANNEL_SELECT)
    {
        // Step 1: Exit states until we reach `TV_ON` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, TV_ON_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHANNEL_SELECT`.
        CHANNEL_SELECT_enter(sm);
        
        // CHANNEL_SELECT.<InitialState> behavior
        // uml: TransitionTo(CHANNEL_SELECT__INITIAL)
        {
            // Step 1: Exit states until we reach `CHANNEL_SELECT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CHANNEL_SELECT__INITIAL`.
            CHANNEL_SELECT__INITIAL_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = TvRemoteSm_StateId_CHANNEL_SELECT__INITIAL;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for CHANNEL_SELECT.<InitialState>
    } // end of behavior for VOLUME_CHANGE
}

static void VOLUME_CHANGE_InitialState_transition(TvRemoteSm* sm)
{
    // VOLUME_CHANGE.<InitialState> behavior
    // uml: TransitionTo(VOLUME_CHANGE__INITIAL)
    {
        // Step 1: Exit states until we reach `VOLUME_CHANGE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `VOLUME_CHANGE__INITIAL`.
        VOLUME_CHANGE__INITIAL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_VOLUME_CHANGE__INITIAL;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for VOLUME_CHANGE.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state VOLUME_CHANGE__INITIAL
////////////////////////////////////////////////////////////////////////////////

static void VOLUME_CHANGE__INITIAL_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = VOLUME_CHANGE__INITIAL_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = VOLUME_CHANGE__INITIAL_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = VOLUME_CHANGE__INITIAL_b2_press;
}

static void VOLUME_CHANGE__INITIAL_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = VOLUME_CHANGE_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void VOLUME_CHANGE__INITIAL_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // VOLUME_CHANGE__INITIAL behavior
    // uml: B1_PRESS TransitionTo(VOLUME_UP)
    {
        // Step 1: Exit states until we reach `VOLUME_CHANGE` state (Least Common Ancestor for transition).
        VOLUME_CHANGE__INITIAL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `VOLUME_UP`.
        VOLUME_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_VOLUME_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for VOLUME_CHANGE__INITIAL
}

static void VOLUME_CHANGE__INITIAL_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // VOLUME_CHANGE__INITIAL behavior
    // uml: B2_PRESS TransitionTo(VOLUME_DOWN)
    {
        // Step 1: Exit states until we reach `VOLUME_CHANGE` state (Least Common Ancestor for transition).
        VOLUME_CHANGE__INITIAL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `VOLUME_DOWN`.
        VOLUME_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_VOLUME_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for VOLUME_CHANGE__INITIAL
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state VOLUME_DOWN
////////////////////////////////////////////////////////////////////////////////

static void VOLUME_DOWN_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = VOLUME_DOWN_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = VOLUME_DOWN_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = VOLUME_DOWN_b2_press;
    
    // VOLUME_DOWN behavior
    // uml: enter / { show("Volume Down");\nvolume_decrement();\nprint_volume() }
    {
        // Step 1: execute action `show("Volume Down");\nvolume_decrement();\nprint_volume()`
        printf("Volume Down");
        if (sm->vars.volume > MIN_VOLUME) { sm->vars.volume--; };
        printf("%d", sm->vars.volume"")
    } // end of behavior for VOLUME_DOWN
}

static void VOLUME_DOWN_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = VOLUME_CHANGE_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void VOLUME_DOWN_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // VOLUME_DOWN behavior
    // uml: B1_PRESS TransitionTo(VOLUME_UP)
    {
        // Step 1: Exit states until we reach `VOLUME_CHANGE` state (Least Common Ancestor for transition).
        VOLUME_DOWN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `VOLUME_UP`.
        VOLUME_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_VOLUME_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for VOLUME_DOWN
}

static void VOLUME_DOWN_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // VOLUME_DOWN behavior
    // uml: B2_PRESS TransitionTo(VOLUME_DOWN)
    {
        // Step 1: Exit states until we reach `VOLUME_CHANGE` state (Least Common Ancestor for transition).
        VOLUME_DOWN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `VOLUME_DOWN`.
        VOLUME_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_VOLUME_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for VOLUME_DOWN
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state VOLUME_UP
////////////////////////////////////////////////////////////////////////////////

static void VOLUME_UP_enter(TvRemoteSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = VOLUME_UP_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = VOLUME_UP_b1_press;
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = VOLUME_UP_b2_press;
    
    // VOLUME_UP behavior
    // uml: enter / { show("Volume Up");\nvolume_increment();\nprint_volume(); }
    {
        // Step 1: execute action `show("Volume Up");\nvolume_increment();\nprint_volume();`
        printf("Volume Up");
        if (sm->vars.volume < MAX_VOLUME) { sm->vars.volume++; };
        printf("%d", sm->vars.volume"");
    } // end of behavior for VOLUME_UP
}

static void VOLUME_UP_exit(TvRemoteSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = VOLUME_CHANGE_exit;
    sm->current_event_handlers[TvRemoteSm_EventId_B1_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[TvRemoteSm_EventId_B2_PRESS] = NULL;  // no ancestor listens to this event
}

static void VOLUME_UP_b1_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b1_press` event.
    
    // VOLUME_UP behavior
    // uml: B1_PRESS TransitionTo(VOLUME_UP)
    {
        // Step 1: Exit states until we reach `VOLUME_CHANGE` state (Least Common Ancestor for transition).
        VOLUME_UP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `VOLUME_UP`.
        VOLUME_UP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_VOLUME_UP;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for VOLUME_UP
}

static void VOLUME_UP_b2_press(TvRemoteSm* sm)
{
    // No ancestor state handles `b2_press` event.
    
    // VOLUME_UP behavior
    // uml: B2_PRESS TransitionTo(VOLUME_DOWN)
    {
        // Step 1: Exit states until we reach `VOLUME_CHANGE` state (Least Common Ancestor for transition).
        VOLUME_UP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `VOLUME_DOWN`.
        VOLUME_DOWN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = TvRemoteSm_StateId_VOLUME_DOWN;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for VOLUME_UP
}

// Thread safe.
char const * TvRemoteSm_state_id_to_string(TvRemoteSm_StateId id)
{
    switch (id)
    {
        case TvRemoteSm_StateId_ROOT: return "ROOT";
        case TvRemoteSm_StateId_TV_OFF: return "TV_OFF";
        case TvRemoteSm_StateId_TV_ON: return "TV_ON";
        case TvRemoteSm_StateId_BRIGHTNESS_CHANGE: return "BRIGHTNESS_CHANGE";
        case TvRemoteSm_StateId_BRIGHTNESS_CHANGE__INITIAL: return "BRIGHTNESS_CHANGE__INITIAL";
        case TvRemoteSm_StateId_BRIGHTNESS_DOWN: return "BRIGHTNESS_DOWN";
        case TvRemoteSm_StateId_BRIGHTNESS_UP: return "BRIGHTNESS_UP";
        case TvRemoteSm_StateId_CHANNEL_SELECT: return "CHANNEL_SELECT";
        case TvRemoteSm_StateId_CHANNEL_DOWN: return "CHANNEL_DOWN";
        case TvRemoteSm_StateId_CHANNEL_SELECT__INITIAL: return "CHANNEL_SELECT__INITIAL";
        case TvRemoteSm_StateId_CHANNEL_UP: return "CHANNEL_UP";
        case TvRemoteSm_StateId_VOLUME_CHANGE: return "VOLUME_CHANGE";
        case TvRemoteSm_StateId_VOLUME_CHANGE__INITIAL: return "VOLUME_CHANGE__INITIAL";
        case TvRemoteSm_StateId_VOLUME_DOWN: return "VOLUME_DOWN";
        case TvRemoteSm_StateId_VOLUME_UP: return "VOLUME_UP";
        default: return "?";
    }
}

// Thread safe.
char const * TvRemoteSm_event_id_to_string(TvRemoteSm_EventId id)
{
    switch (id)
    {
        case TvRemoteSm_EventId_B1_LONG_PRESS: return "B1_LONG_PRESS";
        case TvRemoteSm_EventId_B1_PRESS: return "B1_PRESS";
        case TvRemoteSm_EventId_B2_LONG_PRESS: return "B2_LONG_PRESS";
        case TvRemoteSm_EventId_B2_PRESS: return "B2_PRESS";
        default: return "?";
    }
}
